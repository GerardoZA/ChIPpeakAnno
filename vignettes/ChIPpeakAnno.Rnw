%\VignetteIndexEntry{ChIPpeakAnno Vignette}
%\VignetteDepends{ChIPpeakAnno}
%\VignetteKeywords{ChIP-seq Annotation}
%\VignettePackage{ChIPpeakAnno}

\documentclass[12pt]{article}

<<style, echo=FALSE, results=tex>>=
BiocStyle::latex()
@

\usepackage{hyperref}
\usepackage{url}
\usepackage{fullpage}
\usepackage[authoryear,round]{natbib}
\usepackage[section]{placeins}
\usepackage[stable]{footmisc}
\bibliographystyle{plainnat}

\author{Lihua Julie Zhu\thanks{julie.zhu@umassmed.edu}, 
Jianhong Ou\thanks{jianhong.ou@umassmed.edu},
Jun Yu\thanks{jun.yu@umassmed.edu}}
\begin{document}
\SweaveOpts{concordance=TRUE}
\title{The ChIPpeakAnno user's guide}

\maketitle

\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Chromatin immunoprecipitation (ChIP) followed by DNA sequencing (ChIP-seq) and 
ChIP followed by genome tiling array analysis (ChIP-chip) have become prevalent 
high throughput technologies for identifying the binding sites of DNA-binding 
proteins genome-wise. A number of algorithms have been published to facilitate 
the identification of the binding sites of the DNA-binding proteins of interest.
The identified binding sites as the list of peaks are usually converted to BED 
or bigwig files to be loaded to UCSC genome browser as custom tracks for 
investigators to view the proximity to various genomic features such as genes, 
exons or conserved elements. However, clicking through the genome browser is a 
daunting task if the number of peaks gets large or the peaks spread widely 
across the genome. 

Here we developed \Biocpkg{ChIPpeakAnno}, a Bioconducor package, to facilitate 
the batch annotation of the peaks identified from ChIP-seq or ChIP-chip 
experiments. We implemented functionality to find the nearest gene, exon, miRNA,
gene end or custom features supplied by users such as the most conserved 
elements and other transcription factor binding sites leveraging IRanges. Since 
the genome annotation gets updated frequently, we have leveraged the 
\Biocpkg{biomaRt} package to retrieve the annotation data on the fly. The users 
also have the flexibility to pass their own annotation data or annotation from 
\Biocpkg{GenomicFeatures} as GRanges. We have also leveraged \Biocpkg{BSgenome} 
and \Biocpkg{biomaRt} to retrieve the sequences around the peak identified for 
peak validation or motif discovery. To understand whether the identified peaks 
are enriched around genes with certain GO terms, we have implemented Gene 
Ontology (GO) enrichment test in \Biocpkg{ChIPpeakAnno} package leveraging the 
hypergeometric test phyper in \Biocpkg{stats} package and integrated with GO 
annotation from \Biocpkg{GO.db} package and multiplicity adjustment functions 
from \Biocpkg{multtest} package.


\section{Quick start}
\begin{scriptsize}
<<quickStart>>==
library(ChIPpeakAnno)
## import the MACS output
macs <- system.file("extdata", "MACS_peaks.xls", package="ChIPpeakAnno")
macsOutput <- toGRanges(macs, format="MACS")
## annotate the peaks with ensembl annotation
data(TSS.human.GRCh38)
macs.anno <- annotatePeakInBatch(macsOutput, AnnotationData=TSS.human.GRCh38, 
                                output="overlapping", maxgap=5000L)
## add gene symbols
library(org.Hs.eg.db)
macs.anno <- addGeneIDs(annotatedPeak=macs.anno, 
                        orgAnn="org.Hs.eg.db", 
                        IDs2Add="symbol")

if(interactive()){## annotate the peaks with UCSC annotation
    library(GenomicFeatures)
    library(TxDb.Hsapiens.UCSC.hg38.knownGene)
    ucsc.hg38.knownGene <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
    macs.anno <- annotatePeakInBatch(macsOutput, 
                                     AnnotationData=ucsc.hg38.knownGene, 
                                     output="overlapping", maxgap=5000L)
    macs.anno <- addGeneIDs(annotatedPeak=macs.anno, 
                            orgAnn="org.Hs.eg.db", 
                            feature_id_type="entrez_id",
                            IDs2Add="symbol")
}
@
\end{scriptsize}



\section{A sample workflow using ChIPpeakAnno for ChIP-seq data analysis}
We illustrate here a common downstream analysis workflow for ChIP-seq 
experiments. A list of peaks identified from ChIP-seq experiments are the start 
point of ChIPpeakAnno. Many publically available Chip-seq or Chip-Chip data 
deposited at GEO are in BED format. In ChIPpeakAnno genome intervals such as 
the peaks and annotation data were represented by GRanges. The conversion 
functions \Rfunction{toGRanges} was implemented to convert those files, such as 
BED, GFF, or other user defined dataset such as MACS (a popular peak calling 
program) output file to GRanges. Type ?toGRanges for more information.

First, read the peak files in BED and GFF format and convert them to GRanges,
then, find the overlapped peaks between the two peak sets, and visulize 
the number of common and specific peaks with Venn Diagram.


\begin{scriptsize}
<<workflow19,include=FALSE,fig=TRUE,echo=TRUE>>=
bed <- system.file("extdata", "MACS_output.bed", package="ChIPpeakAnno")
gr1 <- toGRanges(bed, format="BED", header=FALSE) 
## one can also try import from rtracklayer
library(rtracklayer)
gr1.import <- import(bed, format="BED")
identical(start(gr1), start(gr1.import))
gr1[1:2]
gr1.import[1:2] #note the name slot is different from gr1
gff <- system.file("extdata", "GFF_peaks.gff", package="ChIPpeakAnno")
gr2 <- toGRanges(gff, format="GFF", header=FALSE, skip=3)
ol <- findOverlapsOfPeaks(gr1, gr2)
makeVennDiagram(ol)
@
\end{scriptsize}
\incfig{ChIPpeakAnno-workflow19}{.5\textwidth}{}
{venn diagram of overlaps for duplicated experiments}

A pie chart can be used to demonstrate the overlap features of the common peaks.
\begin{scriptsize}
<<workflow20,include=FALSE,fig=TRUE,echo=TRUE>>=
pie1(table(ol$overlappingPeaks[["gr1///gr2"]]$overlapFeature))
@
\end{scriptsize}
\incfig{ChIPpeakAnno-workflow20}{.5\textwidth}{}
{Pie chart of common peaks among features}

We next identify all features within 5kb away from the overlapping peaks using 
\Rfunction{annotatePeakInBatch}. 

\begin{scriptsize}
<<workflow21,include=FALSE,echo=TRUE>>=
overlaps <- ol$peaklist[["gr1///gr2"]]
## ============== old style ===========
## data(TSS.human.GRCh37) 
## overlaps.anno <- annotatePeakInBatch(overlaps, AnnotationData=annoData, 
##                                      output="overlapping", maxgap=5000L)
## overlaps.anno <- addGeneIDs(overlaps.anno, "org.Hs.eg.db", "symbol")
## ============== new style ===========
library(EnsDb.Hsapiens.v75) ##(hg19)
## create annotation file from EnsDb or TxDb
annoData <- annoGR(EnsDb.Hsapiens.v75, feature="gene")
info(annoData)
head(annoData)
overlaps.anno <- annotatePeakInBatch(overlaps, AnnotationData=annoData, 
                                         output="overlapping", maxgap=5000L)
overlaps.anno$gene_name <- 
    annoData$gene_name[match(overlaps.anno$feature,
                             names(annoData))]
head(overlaps.anno)
@
\end{scriptsize}

Once you annotated the peak list, you can plot the distance to nearest feature
such as TSS, for example, plot the distribution of aggregated peak scores or 
peak numbers around transcript start sites
(Figure \ref{ChIPpeakAnno-workflow22}).

\begin{scriptsize}
<<workflow22,include=FALSE,fig=TRUE,echo=TRUE,width=8,height=6>>=
gr1.copy <- gr1
gr1.copy$score <- 1
binOverFeature(gr1, gr1.copy, annotationData=annoData,
               radius=5000, nbins=10, FUN=c(sum, length),
               ylab=c("score", "count"), 
               main=c("Distribution of aggregated peak score around TSS", 
                      "Distribution of aggregated peak numbers around TSS"))
@
\end{scriptsize}
\incfig{ChIPpeakAnno-workflow22}{.8\textwidth}{}{Distribution of aggregated peak 
scores or peak numbers around transcript start sites.}

Summarize peak distribution over exon, intron, enhancer, proximal promoter, 
5 prime UTR and 3 prime UTR in peak centric and nucleotide centric view using 
function 
\Rfunction{assignChromosomeRegion}(Figure \ref{ChIPpeakAnno-workflow23}). 
Setting nucleotideLevel = TRUE will give a nucleotide level distribution over 
different features.

\begin{scriptsize}
<<workflow23,include=FALSE,fig=TRUE,echo=TRUE,width=10,height=4>>=
if(require(TxDb.Hsapiens.UCSC.hg19.knownGene)){
    aCR<-assignChromosomeRegion(gr1, nucleotideLevel=FALSE, 
                           precedence=c("Promoters", "immediateDownstream", 
                                         "fiveUTRs", "threeUTRs", 
                                         "Exons", "Introns"), 
                           TxDb=TxDb.Hsapiens.UCSC.hg19.knownGene)
    barplot(aCR$percentage)
}
@
\end{scriptsize}
\incfig{ChIPpeakAnno-workflow23}{.8\textwidth}{}
{Peak distribution over different genomic features.}

% We can check the position of the peak by \Rfunction{plotRegion} 
% (Figure \ref{ChIPpeakAnno-workflow23},\ref{ChIPpeakAnno-workflow24}).
% \begin{scriptsize}
% <<workflow24,include=FALSE,fig=TRUE,echo=TRUE,width=6,height=3>>=
% plotRegion(gr1.anno, genome="hg19", features=gr1.anno$feature[3:5])
% @
% \end{scriptsize}
% \incfig{ChIPpeakAnno-workflow23}{.8\textwidth}{}
%{plot peak position by features.}
% \begin{scriptsize}
% <<workflow24,include=FALSE,fig=TRUE,echo=TRUE,width=6,height=3>>=
% if(require(TxDb.Hsapiens.UCSC.hg19.knownGene)){
%     plotRegion(intersection.anno, genome="hg19", 
%                start=713790, end=743790, chromosome="chr1", 
%                txdb=TxDb.Hsapiens.UCSC.hg19.knownGene)
% }
% @
% \end{scriptsize}
% \incfig{ChIPpeakAnno-workflow24}{.8\textwidth}{}{plot peak position by given ranges.}

\section{Detail description of the use cases of ChIPpeakAnno}
This section describe some datails in using different functions in ChIPpeakAnno 
for different tasks. As shown in the last section, the common workflow includes:
loading peaks from BED or GFF, or other  sources; determining and visualizing 
the concordance among the biological replicates; combining peaks from 
replicates; associating peaks with rich genomic annotations; summarizing peak 
distributions over exon, intron, enhancer, proximal promoter, 5'UTR and 3'UTR 
regions; retrieving the sequences around the peaks, and analysis of GO and 
pathway enrichment. We break the workflow into 8 tasks in this section.

\subsection{Determine and visualize overlapped peaks with Venn Diagram}

It is important to evaluate the concordance among the peaks of biological 
replicates. Prior to associating features of interest with the peaks, it is a 
common practice to combine peaks from replicates. Also, it is biologically 
interesting to obtaining overlapping peaks from different ChIP peak expereiments
to imply potential transcription factor complexes.  ChIPpeakAnno implemented 
functions to achieve those goals and quatatively determine the significance of 
the overlapping and generate Venn Diagram. 

Here is an example of obtaining overlapping peaks with maximum gap 1kb for 
two peak ranges.

\begin{scriptsize}
<<findOverlapsOfPeaks3>>=
peaks1 <- GRanges(seqnames=c("1", "2", "3", "4", "5", "6", 
                              "2", "6", "6", "6", "6", "5"),
                   ranges=IRanges(start=c(967654, 2010897, 2496704, 3075869, 
                                          3123260, 3857501, 201089, 1543200, 
                                          1557200, 1563000, 1569800, 167889600),
                                  end= c(967754, 2010997, 2496804, 3075969, 
                                         3123360, 3857601, 201089, 1555199,
                                         1560599, 1565199, 1573799, 167893599),
                                  names=paste("Site", 1:12, sep="")),
                  strand="+")

peaks2 <- GRanges(seqnames=c("1", "2", "3", "4", "5", "6", "1", "2", "3", 
                                     "4", "5", "6", "6", "6", "6", "6", "5"),
                          ranges=IRanges(start=c(967659, 2010898, 2496700, 
                                                 3075866, 3123260, 3857500, 
                                                 96765, 201089, 249670, 307586, 
                                                 312326, 385750, 1549800, 
                                                 1554400, 1565000, 1569400,
                                                 167888600), 
                                         end=c(967869, 2011108, 2496920, 
                                               3076166,3123470, 3857780, 
                                               96985, 201299, 249890, 307796, 
                                               312586, 385960, 1550599, 1560799,
                                               1565399, 1571199, 167888999), 
                                         names=paste("t", 1:17, sep="")),
                          strand=c("+", "+", "+", "+", "+", "+", "-", "-", "-", 
                                   "-", "-", "-", "+", "+", "+", "+", "+"))

ol <- findOverlapsOfPeaks(peaks1, peaks2, maxgap=1000)
peaklist <- ol$peaklist
@
\end{scriptsize}

Note: Both BED format and GFF format are common file format that provides a 
flexible way to define the peaks and annotations as the data lines. Therefore, 
conversion functions \Rfunction{toGRanges} were implemented for converting these
data format to GRanges before using other functions in ChIPpeakAnno.

We can get the overlapped peaks with maximum gap 1kb between the two peak 
groups, then draw a pie graph to describe the distribution of the featurs of the 
relative positions of peaks1 to peaks2 for the overlapping peaks.

\begin{scriptsize}
<<overlappingPeaks4,include=FALSE,fig=TRUE,echo=TRUE>>=
overlappingPeaks <- ol$overlappingPeaks
overlappingPeaks
pie1(table(overlappingPeaks[["peaks1///peaks2"]]$overlapFeature))
@
\end{scriptsize}
\incfig{ChIPpeakAnno-overlappingPeaks4}
{.5\textwidth}{}{Pie chart of common peaks among features.}

Here is the merged overlapping peaks, which can be used to obtain overlapping 
peaks with another TF binding sites from a protein complex.

\begin{scriptsize}
<<overlappingPeaks5>>=
peaklist[["peaks1///peaks2"]]
@
\end{scriptsize}

Here is the peaks in peaks1 that not overlaps with peaks in peaks2

\begin{scriptsize}
<<6>>=
peaklist[["peaks1"]]
@
\end{scriptsize}

Here is the peaks in peaks2 that not overlap with peaks in peaks1

\begin{scriptsize}
<<7>>=
peaklist[["peaks2"]]
@
\end{scriptsize}

Venn Diagram can be generated by the following function call using the results 
of \Rfunction{findOverlapsOfPeaks}  as an input 
(Figure \ref{ChIPpeakAnno-findOverlapsOfPeaks8}).

P-values indicate whether the extent of overlapping is significant.
\begin{scriptsize}
<<findOverlapsOfPeaks8,include=FALSE,fig=TRUE,width=6,height=6>>=
makeVennDiagram(ol, totalTest=1e+2)
@
\end{scriptsize}
\incfig{ChIPpeakAnno-findOverlapsOfPeaks8}{.5\textwidth}{}
{venn diagram of overlaps}

Users can also try other tools to draw vennDiagrams such as 
\Rpackage{Vennerable}.

\begin{scriptsize}
<<VennerableFigure,include=FALSE,fig=TRUE,width=6,height=6>>=
#     install.packages("Vennerable", repos="http://R-Forge.R-project.org", 
#                     type="source")
#     library(Vennerable)
#     venn_cnt2venn <- function(venn_cnt){
#         n <- which(colnames(venn_cnt)=="Counts") - 1
#         SetNames=colnames(venn_cnt)[1:n]
#         Weight=venn_cnt[,"Counts"]
#         names(Weight) <- apply(venn_cnt[,1:n], 1, paste, collapse="")
#         Venn(SetNames=SetNames, Weight=Weight)
#     }
# 
#     v <- venn_cnt2venn(ol$venn_cnt)
#     plot(v)
@
\end{scriptsize}

The \Rfunction{findOverlapsOfPeaks} function can be called to obtain overlaps 
up to 5 peak lists for example, the overlap peaks in peaks1, peaks2 and peaks3
(Figure \ref{ChIPpeakAnno-findOverlapsOfPeaks9}). 
\begin{scriptsize}
<<findOverlapsOfPeaks9,include=FALSE,fig=TRUE,echo=TRUE,width=6,height=6>>=
peaks3 <- GRanges(seqnames=c("1", "2", "3", "4", "5", 
                             "6", "1", "2", "3", "4"),
                   ranges=IRanges(start=c(967859, 2010868, 2496500, 3075966,
                                          3123460, 3851500, 96865, 201189, 
                                          249600, 307386),
                                  end= c(967969, 2011908, 2496720, 3076166,
                                         3123470, 3857680, 96985, 201299, 
                                         249890, 307796),
                                  names=paste("p", 1:10, sep="")),
                  strand=c("+", "+", "+", "+", "+", 
                           "+", "-", "-", "-", "-"))

ol <- findOverlapsOfPeaks(peaks1, peaks2, peaks3, maxgap=1000, 
                          connectedPeaks="min")
makeVennDiagram(ol, totalTest=1e+2)
@
\end{scriptsize}
\incfig{ChIPpeakAnno-findOverlapsOfPeaks9}{.5\textwidth}{}
{venn diagram of overlaps for three input peak lists}

Venn Diagram can also be generated by the following function call with p-value
that indicates whether the extent of overlapping is significant 
(Figure \ref{ChIPpeakAnno-makeVennDiagram10},
\ref{ChIPpeakAnno-makeVennDiagram11}). 
Note, the maxgap is changed to 0.
The parameter totalTest in the function makeVennDiagram indicates how many 
potential peaks in total are used in the hypergeometric test. It should be 
larger than the largest number of peaks in the replicates. The smaller it is 
set, the more stringent the test is. The time used to calculate p-value does not
depend on the totalTest. For practical guidance on how to choose totalTest, 
please refer to the post at 
https://stat.ethz.ch/pipermail/bioconductor/2010-November/036540.html.
If you still have trouble in determining the number of totalTest, you could 
have a try with permTest (See Section\ref{permTest})

\begin{scriptsize}
<<makeVennDiagram10,include=FALSE,fig=TRUE,echo=TRUE,width=6,height=6>>=
makeVennDiagram(list(peaks1, peaks2), NameOfPeaks=c("TF1", "TF2"), 
                maxgap=0, minoverlap =1, totalTest=100)
@
\end{scriptsize}
\incfig{ChIPpeakAnno-makeVennDiagram10}{.5\textwidth}{}{Venn diagram to depict 
the overlaps between two peak lists}
\begin{scriptsize}
<<makeVennDiagram11,include=FALSE,fig=TRUE,echo=TRUE,width=6,height=6>>=
makeVennDiagram(list(peaks1, peaks2, peaks3), 
                NameOfPeaks=c("TF1", "TF2", "TF3"),
                maxgap=0, minoverlap =1, totalTest=100)
@
\end{scriptsize}
\incfig{ChIPpeakAnno-makeVennDiagram11}{.5\textwidth}{}{venn diagram of overlaps
for three input peaklists directly}

\subsection{Generate annotation data}
One main function of ChIPpeakAnno package is to annotate the positional 
relationship between the peaks and known features, such as TSS, 5UTR, 3UTR etc. 
Constructing and choosing the appropriate annotation data is crucial for this 
process. 

To simplify this process, We precompiled the annotation data for the 
transcriptional starting sites (TSS) of the other species (with 
different genome assembly versions). Those TSS annotations include 
TSS.human.NCBI36, TSS.human.GRCh37, TSS.human.GRCh38, TSS.mouse.NCBIM37, 
TSS.mouse.GRCm38, TSS.rat.RGSC3.4, TSS.rat.Rnor\_5.0, TSS.zebrafish.Zv8, and 
TSS.zebrafish.Zv9. You can access those annotations by R data() function.

To annotate the peaks with other genomic feature, we provided the function
\Rfunction{getAnnotation} with the argument featureType, e.g., ``Exon" to obtain 
 the nearest exon, and ``miRNA" for finding the nearest miRNA, ``5utr" or
 ``3utr" to locate the overlapping ``5UTR" or ``3UTR". You need pass to the
function \Rfunction{getAnnotation} the appropriate biomaRt dataset for example, 
drerio\_gene\_ensembl for zebrafish genome, mmusculus\_gene\_ensembl for mouse 
genome and rnorvegicus\_gene\_ensembl for rat genome. For a list of available 
biomart and dataset, please refer to the \Biocpkg{biomaRt} package documentation
(Durinck S. et al., 2005).  For the detailed usage of getAnnotation, you can
type ?getAnnotation in R.

You can also pass your own annotation data into the function 
\Rfunction{annotatePeakInBatch}. For example, if you have a list of 
transcription factor biding sites from literatures and are interested in 
obtaining the nearest binding site of the transcription factor and distance to 
it for the list of peaks.

In the newer version of the ChIPpeakAnno (3.3.5), we also implement an 
\Rfunction{annoGR} class,  which is an extension of GRanges class, to represent 
the annotation data. An annoGR object can be created by calling the 
\Rfunction{annoGR}() 
function. The AnnoGR can be constructed from EnsDb, TxDb, or the user defined 
GRanges object. It saves the annotation info in GRanges and it also has
metadata to save the information related to the annotation such as create date, 
source and so on.The advatange of this class is that it contains the meta data 
such as the source and the timestampe (date) of the data souce. Use ?annoGR for 
more information. 

You can also determine to use the biological appropriate database that is 
related with your biological questions. For example, if you only want to 
annotate only the known genes, not other transcipt 
products, such as pseudo genes, you can use the Transcript Db
TxDb.Hsapiens.UCSC.hg19.knownGene. A sample code to build your annotation data 
is: 
<<annoGRgene>>=
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
annoData <- annoGR(TxDb.Hsapiens.UCSC.hg19.knownGene, feature="gene")
info(annoData)
annoData
@

\subsection{Find the nearest feature such as gene and the distance to 
the feature such as the transcription start site (TSS) of the nearest gene}

Once we have the annotation data, we can annotate the peaks identified from 
ChIP-seq or ChIP-chip experiments to retrieve the nearest gene and distance to 
the corresponding gene transcription start site. As discussed in the last 
section,  all the genomic locations of the human genes has been precomplied as 
TSS.human.NCBI36 dataset using function \Rfunction{getAnnotation}. We can pass 
to the argument annotaionData of the \Rfunction{annotatePeakInBatch} function.

\begin{scriptsize}
<<annotatePeakInBatch1>>=
library(ChIPpeakAnno)
data(myPeakList)
data(TSS.human.NCBI36)
annotatedPeak <- annotatePeakInBatch(myPeakList[1:6,], 
                 AnnotationData=TSS.human.NCBI36)
annotatedPeak
@
\end{scriptsize}

We can also pass the used defined features as annotationData. After we annotated
those peaks, a pie chart can be plotted to show the peak distributions among the
features.

\begin{scriptsize}
<<annotatePeakInBatch2,include=TRUE,echo=TRUE>>=
myPeak1 <- GRanges(seqnames=c("1", "2", "3", "4", "5", "6", 
                              "2", "6", "6", "6", "6", "5"),
                   ranges=IRanges(start=c(967654, 2010897, 2496704, 3075869, 
                                          3123260, 3857501, 201089, 1543200, 
                                          1557200, 1563000, 1569800, 167889600),
                                  end= c(967754, 2010997, 2496804, 3075969, 
                                         3123360, 3857601, 201089, 1555199,
                                         1560599, 1565199, 1573799, 167893599),
                                  names=paste("Site", 1:12, sep="")))

TFbindingSites <- GRanges(seqnames=c("1", "2", "3", "4", "5", "6", "1", "2", 
                                     "3", "4", "5", "6", "6", "6", "6", "6",
                                     "5"),
                          ranges=IRanges(start=c(967659, 2010898, 2496700, 
                                                 3075866, 3123260, 3857500, 
                                                 96765, 201089, 249670, 307586, 
                                                 312326, 385750, 1549800, 
                                                 1554400, 1565000, 1569400,
                                                 167888600), 
                                         end=c(967869, 2011108, 2496920, 
                                               3076166,3123470, 3857780, 
                                               96985, 201299, 249890, 307796, 
                                               312586, 385960, 1550599, 1560799,
                                               1565399, 1571199, 167888999), 
                                         names=paste("t", 1:17, sep="")),
                          strand=c("+", "+", "+", "+", "+", "+", "-", "-", "-", 
                                   "-", "-", "-", "+", "+", "+", "+", "+"))

annotatedPeak2 <- annotatePeakInBatch(myPeak1, AnnotationData=TFbindingSites)
annotatedPeak2
@
<<pie1,fig=TRUE,include=FALSE,width=5,height=5>>=
pie1(table(as.data.frame(annotatedPeak2)$insideFeature))
@
\end{scriptsize}
\incfig{ChIPpeakAnno-pie1}{.5\textwidth}{}{Pie chart of peak distribution among 
features.}

In the function annotatyePeakInBatch, you can adjust various parameters to 
specify the way to calculate the distance and how the features be selected. For
example, PeakLocForDistance is to specify the location of the peak to calculate 
the distance: "middle" (recommended) means using the middle of the peak, and 
"start" (default, for backward compatibility) means using the start of the peak 
to calculate the distance to features. Similarly, FeatureLocForDistance is to 
specify the location of feature for distance caculation: "middle" means using 
the middle of the feature, "start" means using start of the feature to calculate
the distance from the peak to the feature;  "TSS" (default) means using the 
start of the feature when the feature is on plus strand and using the end of 
feature when the feature is on minus strand; "geneEnd" means using end of the 
feature when feature is on plus strand and using start of feature when feature 
is on minus strand. 

The argument "output" specifies the characteristics of the output of the 
annotated features. The default is "nearestLocation", which means to output the 
nearest features calculated as PeakLocForDistance-FeatureLocForDistance; 
"overlapping" will output overlapping features with maximum gap specified as 
maxgap between peak range and feature range; "shortestDistance" will output the 
nearest features; "both" will output all the nearest features, in addition, will
output any features that overlap the peak that is not the nearest features. 
"upstream\&inside" will output all upstream and overlapping features with maximum
gap. "inside\&downstream" will output all downstream and overlapping features 
within the maximum gap; "upstream" will output all upstream features with 
maximum gap; "downstream" will output all downstream features with maximum gap; 
"upstreamORdownstream" will output all upstream features with maximum gap or 
downstream with maximum gap.

\subsection{Add other feature IDs to the annotated peaks}

Additional annotations such as entrez ID, gene symbol and gene name can be added
using function addGeneIDs and the annotated peaks can be saved as an Excel file 
or plotted for visualizing the peak distribution relative to the genomic 
features of interest. Here is an example to add gene symbol to annotated peaks.

\begin{scriptsize}
<<addGeneIDs18>>=
data(annotatedPeak)
library(org.Hs.eg.db)
addGeneIDs(annotatedPeak[1:6,], orgAnn="org.Hs.eg.db", IDs2Add=c("symbol"))
addGeneIDs(annotatedPeak$feature[1:6], orgAnn="org.Hs.eg.db", 
           IDs2Add=c("symbol"))
@
\end{scriptsize}


\subsection{Obtain sequences surrounding the peaks}

Here is an example of obtaining sequences surrounding the peak intervals 
including 20 bp upstream and downstream sequence for PCR validation or motif 
discovery.

\begin{scriptsize}
<<getAllPeakSequence12>>=
peaks <- GRanges(seqnames=c("NC_008253", "NC_010468"),
                 ranges=IRanges(start=c(100, 500), 
                                end=c(300, 600), 
                                names=c("peak1", "peak2")))
library(BSgenome.Ecoli.NCBI.20080805)
peaksWithSequences <- getAllPeakSequence(peaks, upstream=20, 
                                         downstream=20, genome=Ecoli)
@
\end{scriptsize}

The obtained sequences can be converted to fasta format for motif 
discovery by calling the function \Rfunction{write2FASTA}.

\begin{scriptsize}
<<write2FASTA13>>=
write2FASTA(peaksWithSequences,"test.fa")
@ 
\end{scriptsize}

\subsection{Heatmap of given peak ranges}

You can easily observe the signals of multiple Chip-Seq peak files by 
\Rfunction{featureAlignedHeatmap} (Figure \ref{ChIPpeakAnno-heatmap} and
\Rfunction{featureAlignedDistribution} (Figure \ref{ChIPpeakAnno-Distribution}.

\begin{scriptsize}
<<heatmap,include=FALSE,fig=TRUE,echo=TRUE,width=4,height=6>>=
path <- system.file("extdata", package="ChIPpeakAnno")
files <- dir(path, "broadPeak")
data <- sapply(file.path(path, files), toGRanges, format="broadPeak")
names(data) <- gsub(".broadPeak", "", files)
ol <- findOverlapsOfPeaks(data)
#makeVennDiagram(ol)
features <- ol$peaklist[[length(ol$peaklist)]]
wid <- width(features)
feature.recentered <- feature.center <- features
start(feature.center) <- start(features) + floor(wid/2)
width(feature.center) <- 1
start(feature.recentered) <- start(feature.center) - 2000
end(feature.recentered) <- end(feature.center) + 2000
## here we also suggest importData function in trackViewer package 
## to import the coverage.
## compare rtracklayer, it will save you time when handle huge dataset.
library(rtracklayer)
files <- dir(path, "bigWig")
cvglists <- sapply(file.path(path, files), import, 
                       format="BigWig", 
                       which=feature.recentered, 
                       as="RleList")
names(cvglists) <- gsub(".bigWig", "", files)
sig <- featureAlignedSignal(cvglists, feature.center, 
                            upstream=2000, downstream=2000) 
heatmap <- featureAlignedHeatmap(sig, feature.center, 
                                 upstream=2000, downstream=2000,
                                 upper.extreme=c(3,.5,4))
@
\end{scriptsize}
\incfig{ChIPpeakAnno-heatmap}{.5\textwidth}{}{Heatmap of aligned features.}

\begin{scriptsize}
<<distribution,include=FALSE,fig=TRUE,echo=TRUE,width=6,height=6>>=
featureAlignedDistribution(sig, feature.center, 
                           upstream=2000, downstream=2000,
                           type="l")
@
\end{scriptsize}
\incfig{ChIPpeakAnno-Distribution}{.5\textwidth}{}
{Distribution of aligned features.}


\subsection{Output a summary of motif occurrence in the peaks.}

Here is an example to search the peaks for the motifs in examplepattern.fa file.

\begin{scriptsize}
<<summarizePatternInPeaks17>>=
peaks <- GRanges(seqnames=c("NC_008253", "NC_010468"),
                 ranges=IRanges(start=c(100, 500), 
                                end=c(300, 600), 
                                names=c("peak1", "peak2")))
filepath <- system.file("extdata", "examplePattern.fa", package="ChIPpeakAnno")
library(BSgenome.Ecoli.NCBI.20080805)
summarizePatternInPeaks(patternFilePath=filepath, format="fasta", skip=0L, 
                        BSgenomeName=Ecoli, peaks=peaks)
@
\end{scriptsize}


\subsection{Obtain enriched gene ontology (GO) terms or KEGG terms near the 
peaks}

Once you have obtained the annotated peak data from the example above, 
you can also use the function \Rfunction{getEnriched} to obtain a list of 
enriched gene ontology (GO) terms via \Biocannopkg{GOstats}. The ontology could 
also be set as KEGG or reactome. 

Once you have obtained the annotated peak data from the example above, you can 
use the function \Rfunction{getEnrichedGO} to obtain a list of enriched 
gene ontology (GO) terms using hypergeometric test.

library(org.Hs.eg.db)

$enrichedGO = getEnrichedGO$
(annotatedPeak, 
$orgAnn=``org.Hs.eg.db"$, 
$maxP=0.01$, 
$multiAdj=TRUE$,  
$minGOterm=10$, 
$multiAdjMethod=``BH" $ 
)

\begin{scriptsize}
<<getEnriched14>>=
library(org.Hs.eg.db)
over <- getEnrichedGO(annotatedPeak[1:500], orgAnn="org.Hs.eg.db", 
                    maxP=0.01, multiAdj=FALSE, minGOterm=10, 
                    multiAdjMethod="", condense=FALSE)
head(over[["bp"]][, -3])
head(over[["cc"]][, -3])
head(over[["mf"]][, -3])
@ 
\end{scriptsize}

Please note that org.Hs.eg.db is the GO gene mapping for Human, for other 
organisms, please refer to 
http://www.bioconductor.org/packages/release/data/annotation/ 
for additional org.xx.eg.db packages.
Or you can try \Rfunction{egOrgMap} to get the annotation database.

\begin{scriptsize}
<<egOrgMap15>>=
egOrgMap("Mus musculus")
egOrgMap("Homo sapiens")
@
\end{scriptsize}

\subsection{Find peaks with bi-directional promoters}

The definition from Wikepedia: Bidirectional promoters are short (<1 kbp), 
intergenic regions of DNA between the 5' ends of the genes in a bidirectional 
gene pair.A "bidirectional gene pair" refers to two adjacent genes coded on 
opposite strands, with their 5' ends oriented toward one another. The two genes 
are often functionally related, and modification of their shared promoter region
allows them to be co-regulated and thus co-expressed. Here is an example to find
peaks with bi-directional promoters and output percent of peaks near 
bi-directional promoters.

\begin{scriptsize}
<<peaksNearBDP16>>=
data(myPeakList)
data(TSS.human.NCBI36)
annotatedBDP <- peaksNearBDP(myPeakList[1:10,], 
                             AnnotationData=TSS.human.NCBI36, 
                             MaxDistance=5000,
                             PeakLocForDistance="middle", 
                             FeatureLocForDistance="TSS")
annotatedBDP$peaksWithBDP
c(annotatedBDP$percentPeaksWithBDP, 
  annotatedBDP$n.peaks, 
  annotatedBDP$n.peaksWithBDP)
@
\end{scriptsize}

\subsection{Perform permutation test to determine if there is an association 
between two set of peaks}\label{permTest}

If there are two peak lists from two transcript factors (TFs), we want to know 
whether or not they are related TFs. Previously, most of the tests are based on 
hyper-geometric distribution. However, to estimate the total potential binding 
positions for a given TF is not an easy work. With \Rfunction{peakPermTest} 
and the right biological data, it is possible to answer this question properly. 
The random peaks in the permutation test are generated by special strategy. 
First the input peaks1 will be annotated into a given genome to discovery its 
distribution form a given feature type (transcripts or exons). And then the 
random peaks will be generated based on this distribution. The width of the 
peaks also follow the distribution of inputs.

Here we show the samples:

\begin{scriptsize}
<<peakPermTest>>=
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
cds <- unique(unlist(cdsBy(txdb)))
utr5 <- unique(unlist(fiveUTRsByTranscript(txdb)))
utr3 <- unique(unlist(threeUTRsByTranscript(txdb)))
set.seed(123)
utr3 <- utr3[sample.int(length(utr3), 1000)]
pt <- peakPermTest(utr3, 
             utr5[sample.int(length(utr5), 1000)], 
             maxgap=500,
             TxDb=txdb, seed=1,
             force.parallel=FALSE)
pt$zscore
## high relevant peaks
ol <- findOverlaps(cds, utr3, maxgap=1)
pt1 <- peakPermTest(utr3,
             c(cds[sample.int(length(cds), 500)], 
                cds[queryHits(ol)][sample.int(length(ol), 500)]), 
             maxgap=500, 
             TxDb=txdb, seed=1,
             force.parallel=FALSE)
pt1$zscore
@
\end{scriptsize}

For permutation test, the permutation pool is very important. If you do not 
set the pool, peakPermTest will generated the data for permutation test 
depending on your input peaks1, TxDb, bindingType and featureType. But for 
ChIP-seq, the pool usually will be bigger than the reality. So we generated a
possible binding pool for human (Try ?wgEncodeTfbsV3 to see more details) from 
transcription factor binding site clusters (V3) from ENCODE data and remove 
the HOT spots. Also we provided the HOT spots files (Try ?HOT.spots to see 
more details). The following code is the sample code to run the permutation 
test.

\begin{scriptsize}
<<peakPermTest1>>=
if(interactive()){
    data(HOT.spots)
    data(wgEncodeTfbsV3)
    hotGR <- reduce(unlist(HOT.spots))
    removeOl <- function(.ele){
        ol <- findOverlaps(.ele, hotGR)
        if(length(ol)>0) .ele <- .ele[-unique(queryHits(ol))]
        .ele
    }
    TAF <- removeOl(data[["TAF"]])
    Tead4 <- removeOl(data[["Tead4"]])
    pool <- new("permPool", grs=GRangesList(wgEncodeTfbsV3), N=length(TAF))
    pt <- peakPermTest(TAF, Tead4, pool=pool, ntimes=1000)
    pt$zscore
}
@
\end{scriptsize}

\section{References}
1. Y. Benjamini and Y. Hochberg (1995). Controlling the false discovery rate: a 
practical and powerful approach to multiple testing. J. R. Statist. Soc. B. Vol.
57: 289-300. 
\\2. Y. Benjamini and D. Yekutieli (2001). The control of the false discovery 
rate in multiple hypothesis testing under dependency. Annals of Statistics. 
\\3. S. Durinck et al. (2005) BioMart and Bioconductor: a powerful link between 
biological biomarts and microarray data analysis. Bioinformatics, 21, 3439-3440. 
\\4. S. Dudoit, J. P. Shaffer, and J. C. Boldrick (Submitted). Multiple 
hypothesis testing in microarray experiments. 
\\5. Y. Ge, S. Dudoit, and T. P. Speed. Resampling-based multiple testing for 
microarray data hypothesis, Technical Report \#633 of UCB Stat. 
http://www.stat.berkeley.edu/~gyc 
\\6. R. Gentleman et al. (2004) Bioconductor: open software development for 
computational biology and bioinformatics. Genome Biol., 5:R80
\\7. Y. Hochberg (1988). A sharper Bonferroni procedure for multiple tests of 
significance, Biometrika. Vol. 75: 800-802. 
\\8. S. Holm (1979). A simple sequentially rejective multiple test procedure. 
Scand. J. Statist.. Vol. 6: 65-70. 
\\9. N. L. Johnson,S. Kotz and A. W. Kemp (1992) Univariate Discrete 
Distributions, Second Edition. New York: Wiley
\\10. G. Robertson et al. (2007) Genome-wide profiles of STAT1 DNA association 
using chromatin immunoprecipitation and massively parallel sequencing. Nat 
Methods, 4:651-7.
\\11. Zhu L.J. et al. (2010) ChIPpeakAnno: a Bioconductor package to annotate 
ChIP-seq and ChIP-chip data. BMC Bioinformatics 2010, 
11:237doi:10.1186/1471-2105-11-237.
\\12. Zhu L.J. (2013) Integrative analysis of ChIP-chip and ChIP-seq dataset. 
Methods Mol Biol. 2013;1067:105-24. doi: 10.1007/978-1-62703-607-8\_8.

\section{Session Info}
<<sessionInfo, results=tex, print=TRUE>>=
toLatex(sessionInfo())
@

\end{document}
