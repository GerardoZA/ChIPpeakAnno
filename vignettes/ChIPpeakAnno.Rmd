---
title: "The ChIPpeakAnno user's guide"
author: "Jianhong Ou, Jun Yu, Lihua Julie Zhu"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{ChIPpeakAnno Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({
    library(ChIPpeakAnno)
    library(org.Hs.eg.db)
    library(GenomicFeatures)
    library(TxDb.Hsapiens.UCSC.hg38.knownGene)
    library(rtracklayer)
    library(GO.db)
    library(EnsDb.Hsapiens.v75)
    library(BSgenome.Ecoli.NCBI.20080805)
})
```

# Introduction

Chromatin immunoprecipitation (ChIP) followed by DNA sequencing (ChIP-seq) and 
ChIP followed by genome tiling array analysis (ChIP-chip) have become prevalent 
high throughput technologies for identifying the binding sites of DNA-binding 
proteins genome-wise. A number of algorithms have been published to facilitate 
the identification of the binding sites of the DNA-binding proteins of interest.
The identified binding sites as the list of peaks are usually converted to BED 
or bigwig files to be loaded to the UCSC genome browser as custom tracks for 
investigators to view the proximity to various genomic features such as genes, 
exons or conserved elements. However, clicking through the genome browser is a 
daunting task when the number of peaks gets large or the peaks spread widely 
across the genome. 

Here we developed **ChIPpeakAnno**, a Bioconducor package, to facilitate 
the batch annotation of the peaks identified from ChIP-seq or ChIP-chip 
experiments. We implemented functionality to find the nearest gene, exon, miRNA,
gene end or custom features supplied by users such as the most conserved 
elements and other transcription factor binding sites leveraging GRanges. Since 
the genome annotation gets updated frequently, we have leveraged the 
**biomaRt** package to retrieve the annotation data on the fly. The users 
also have the flexibility to pass their own annotation data or annotation from 
**GenomicFeatures** as GRanges. We have also leveraged **BSgenome** 
and **biomaRt** to retrieve the sequences around the peak identified for 
peak validation or motif discovery. To understand whether the identified peaks 
are enriched around genes with certain GO terms, we have implemented the Gene 
Ontology (GO) enrichment test in the **ChIPpeakAnno** package leveraging the 
hypergeometric test phyper in the **stats** package and integrated with the GO 
annotation from the **GO.db** package and multiplicity adjustment functions 
from the **multtest** package.


# Quick start
```{r quickStart}
library(ChIPpeakAnno)
## import the MACS output
macs <- system.file("extdata", "MACS_peaks.xls", package="ChIPpeakAnno")
macsOutput <- toGRanges(macs, format="MACS")
## annotate the peaks with ensembl annotation
data(TSS.human.GRCh38)
macs.anno <- annotatePeakInBatch(macsOutput, AnnotationData=TSS.human.GRCh38, 
                                output="overlapping", maxgap=5000L)
## add gene symbols
library(org.Hs.eg.db)
macs.anno <- addGeneIDs(annotatedPeak=macs.anno, 
                        orgAnn="org.Hs.eg.db", 
                        IDs2Add="symbol")

if(interactive()){## annotate the peaks with UCSC annotation
    library(GenomicFeatures)
    library(TxDb.Hsapiens.UCSC.hg38.knownGene)
    ucsc.hg38.knownGene <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
    macs.anno <- annotatePeakInBatch(macsOutput, 
                                     AnnotationData=ucsc.hg38.knownGene, 
                                     output="overlapping", maxgap=5000L)
    macs.anno <- addGeneIDs(annotatedPeak=macs.anno, 
                            orgAnn="org.Hs.eg.db", 
                            feature_id_type="entrez_id",
                            IDs2Add="symbol")
}
```



# A sample workflow using ChIPpeakAnno for ChIP-seq data analysis
We illustrate here a common downstream analysis workflow for ChIP-seq 
experiments. A list of peaks identified from ChIP-seq experiments are the start 
point of using ChIPpeakAnno. Many publically available Chip-seq or Chip-Chip
data at GEO are in BED format. In ChIPpeakAnno genome intervals such as 
the peaks and annotation data were represented by GRanges. The conversion 
functions `toGRanges` was implemented to convert those files, such as 
BED, GFF, or other user defined dataset such as MACS (a popular peak calling 
program) output file to GRanges. Type ?`toGRanges` for more information.

First, read the peak files in BED and GFF format and convert them to GRanges,
then, find the overlapped peaks between the two peak sets, and visulize 
the number of common and specific peaks with Venn Diagram.


```{r workflow19, fig.cap="venn diagram of overlaps for duplicated experiments"}
bed <- system.file("extdata", "MACS_output.bed", package="ChIPpeakAnno")
gr1 <- toGRanges(bed, format="BED", header=FALSE) 
## one can also try import from rtracklayer
library(rtracklayer)
gr1.import <- import(bed, format="BED")
identical(start(gr1), start(gr1.import))
gr1[1:2]
gr1.import[1:2] #note the name slot is different from gr1
gff <- system.file("extdata", "GFF_peaks.gff", package="ChIPpeakAnno")
gr2 <- toGRanges(gff, format="GFF", header=FALSE, skip=3)
ol <- findOverlapsOfPeaks(gr1, gr2)
makeVennDiagram(ol)
```

A pie chart is used to demonstrate the overlap features of the common peaks.

```{r workflow20,fig.cap="Pie chart of common peaks among features"}
pie1(table(ol$overlappingPeaks[["gr1///gr2"]]$overlapFeature))
```

`annotatePeakInBatch` is used to identify all the features within 5kb away from 
the overlapping peaks. 
. 

```{r workflow21}
overlaps <- ol$peaklist[["gr1///gr2"]]
## ============== old style ===========
## data(TSS.human.GRCh37) 
## overlaps.anno <- annotatePeakInBatch(overlaps, AnnotationData=annoData, 
##                                      output="overlapping", maxgap=5000L)
## overlaps.anno <- addGeneIDs(overlaps.anno, "org.Hs.eg.db", "symbol")
## ============== new style ===========
library(EnsDb.Hsapiens.v75) ##(hg19)
## create annotation file from EnsDb or TxDb
annoData <- annoGR(EnsDb.Hsapiens.v75, feature="gene")
info(annoData)
head(annoData)
overlaps.anno <- annotatePeakInBatch(overlaps, AnnotationData=annoData, 
                                    output="overlapping", maxgap=5000L)
overlaps.anno$gene_name <- 
    annoData$gene_name[match(overlaps.anno$feature,
                             names(annoData))]
head(overlaps.anno)
```

Once the peak list is annotated, you can plot the distribution of the distance to the nearest feature
such as the TSS. For example, plot the distribution of aggregated peak scores or 
peak numbers around the transcript start sites.

```{r workflow22,fig.cap="Distribution of aggregated peak scores or peak numbers around transcript start sites.",fig.width=8,fig.height=6}
gr1.copy <- gr1
gr1.copy$score <- 1
binOverFeature(gr1, gr1.copy, annotationData=annoData,
               radius=5000, nbins=10, FUN=c(sum, length),
               ylab=c("score", "count"), 
               main=c("Distribution of aggregated peak scores around TSS", 
                      "Distribution of aggregated peak numbers around TSS"))
```

Summarize peak distribution over exon, intron, enhancer, proximal promoter, 
5 prime UTR and 3 prime UTR in peak centric or nucleotide centric view using 
function `assignChromosomeRegion`. 
Setting nucleotideLevel = TRUE will give a nucleotide level distribution over 
different features.

```{r workflow23,fig.cap="Peak distribution over different genomic features.",fig.width=10,fig.height=4}
if(require(TxDb.Hsapiens.UCSC.hg19.knownGene)){
    aCR<-assignChromosomeRegion(gr1, nucleotideLevel=FALSE, 
                           precedence=c("Promoters", "immediateDownstream", 
                                         "fiveUTRs", "threeUTRs", 
                                         "Exons", "Introns"), 
                           TxDb=TxDb.Hsapiens.UCSC.hg19.knownGene)
    barplot(aCR$percentage)
}
```

# Detail Use Cases and Scenarios of ChIPpeakAnno

Here we describe some datails in using different functions in ChIPpeakAnno 
for different tasks. As shown in the last section, the common workflow includes:
loading peaks from BED or GFF, or other  sources; determining and visualizing 
the concordance among the biological replicates; combining peaks from 
replicates; creating annotation GRanges; associating peaks with rich genomic annotations; summarizing peak 
distributions over exon, intron, enhancer, proximal promoter, 5'UTR and 3'UTR 
regions; retrieving the sequences around the peaks, and analysis of GO and 
pathway enrichment. In the newer version of ChIPpeakAnno, we also implement the 
functions to plot the heatmap of given peak ranges, and perform permutation test
to determine if there is an association between two set of peaks. 
We break the workflow into 10 tasks in this section.

## Determine the overlapped peaks and visulize with Venn Diagram

It is important to evaluate the concordance among the peaks of biological 
replicates. Prior to associating features of interest with the peaks, it is a 
common practice to combine peaks from replicates. Also, it is biologically 
interesting to obtaining overlapping peaks from different ChIP peak expereiments
to imply potential transcription factor complexes. ChIPpeakAnno implemented 
functions to achieve those goals and quatatively determine the significance of 
peak overlaps and generate a Venn Diagram for visulization. 

Here is an sample code to obtain the overlapping peaks with maximum gap 1kb for 
two peak ranges.

```{r findOverlapsOfPeaks3}
peaks1 <- GRanges(seqnames=c("1", "2", "3", "4", "5", "6", 
                              "2", "6", "6", "6", "6", "5"),
                   ranges=IRanges(start=c(967654, 2010897, 2496704, 3075869, 
                                          3123260, 3857501, 201089, 1543200, 
                                          1557200, 1563000, 1569800, 167889600),
                                  end= c(967754, 2010997, 2496804, 3075969, 
                                         3123360, 3857601, 201089, 1555199,
                                         1560599, 1565199, 1573799, 167893599),
                                  names=paste("Site", 1:12, sep="")),
                  strand="+")

peaks2 <- GRanges(seqnames=c("1", "2", "3", "4", "5", "6", "1", "2", "3", 
                                     "4", "5", "6", "6", "6", "6", "6", "5"),
                          ranges=IRanges(start=c(967659, 2010898, 2496700, 
                                                 3075866, 3123260, 3857500, 
                                                 96765, 201089, 249670, 307586, 
                                                 312326, 385750, 1549800, 
                                                 1554400, 1565000, 1569400,
                                                 167888600), 
                                         end=c(967869, 2011108, 2496920, 
                                               3076166,3123470, 3857780, 
                                               96985, 201299, 249890, 307796, 
                                               312586, 385960, 1550599, 1560799,
                                               1565399, 1571199, 167888999), 
                                         names=paste("t", 1:17, sep="")),
                          strand=c("+", "+", "+", "+", "+", "+", "-", "-", "-", 
                                   "-", "-", "-", "+", "+", "+", "+", "+"))

ol <- findOverlapsOfPeaks(peaks1, peaks2, maxgap=1000)
peaklist <- ol$peaklist
```

The function `findOverlapsOfPeaks` returns an object of **overlappingPeaks**, 
which contains elements: venn_cnt, peaklist (a list consists of all 
overlapping peaks or unique peaks), and overlappingPeaks (a list of data frame 
consists of the annotation of all the overlapped peaks). 

Within the overlapplingPeaks element of **overlappingPeaks** object ol (which is also a list), the element 
"peaks1///peaks2" is the data frame represneting the overlapped peaks with maximum gap 1kb between the two peak 
groups. Using the overlapFeature column in this dataframe we can draw a pie graph to describe the distribution of the featurs of the 
relative positions of peaks1 to peaks2 for the overlapping peaks.

```{r overlappingPeaks4,fig.cap="Pie chart of common peaks among features."}
overlappingPeaks <- ol$overlappingPeaks
overlappingPeaks
pie1(table(overlappingPeaks[["peaks1///peaks2"]]$overlapFeature))
```

The following code returns the merged overlapping peaks from the peaklist, which could be used for the downstream analysis.


```{r overlappingPeaks5}
peaklist[["peaks1///peaks2"]]
```


The peaks in peaks1 but not overlaps with peaks in peaks2 can be accessed with: 


```{r 6}
peaklist[["peaks1"]]
```


and the peaks in peaks2 but not overlap with peaks in peaks1 can be accessed with


```{r 7}
peaklist[["peaks2"]]
```

Venn Diagram can be generated by the function `makeVennDiagram` using the results 
of `findOverlapsOfPeaks`  as an input.

P-values indicate whether the extent of overlapping is significant.

```{r findOverlapsOfPeaks8,fig.cap="venn diagram of overlaps",fig.width=6,fig.height=6}
makeVennDiagram(ol, totalTest=1e+2)
```

Users can also use other tools to draw Venn diagram such as **Vennerable**.


```{r VennerableFigure}
#     install.packages("Vennerable", repos="http://R-Forge.R-project.org", 
#                     type="source")
#     library(Vennerable)
#     venn_cnt2venn <- function(venn_cnt){
#         n <- which(colnames(venn_cnt)=="Counts") - 1
#         SetNames=colnames(venn_cnt)[1:n]
#         Weight=venn_cnt[,"Counts"]
#         names(Weight) <- apply(venn_cnt[,1:n], 1, paste, collapse="")
#         Venn(SetNames=SetNames, Weight=Weight)
#     }
# 
#     v <- venn_cnt2venn(ol$venn_cnt)
#     plot(v)
```


The `findOverlapsOfPeaks` function can be called to obtain overlaps 
up to 5 peak lists for example, the overlap peaks in peaks1, peaks2 and peaks3. 

```{r findOverlapsOfPeaks9,fig.cap="venn diagram of overlaps for three input peak lists",fig.width=6,fig.height=6}
peaks3 <- GRanges(seqnames=c("1", "2", "3", "4", "5", 
                             "6", "1", "2", "3", "4"),
                   ranges=IRanges(start=c(967859, 2010868, 2496500, 3075966,
                                          3123460, 3851500, 96865, 201189, 
                                          249600, 307386),
                                  end= c(967969, 2011908, 2496720, 3076166,
                                         3123470, 3857680, 96985, 201299, 
                                         249890, 307796),
                                  names=paste("p", 1:10, sep="")),
                  strand=c("+", "+", "+", "+", "+", 
                           "+", "-", "-", "-", "-"))

ol <- findOverlapsOfPeaks(peaks1, peaks2, peaks3, maxgap=1000, 
                          connectedPeaks="min")
makeVennDiagram(ol, totalTest=1e+2)
```

Venn Diagram can also be generated by the following function call with p-value
that indicates whether the extent of overlapping is significant. 
Note: the maxgap is changed to 0.
The parameter totalTest in the function makeVennDiagram indicates how many 
potential peaks in total are used in the hypergeometric test. It should be 
larger than the largest number of peaks in the replicates. The smaller it is 
set, the more stringent the test is. The time used to calculate p-value does not
depend on the totalTest. For practical guidance on how to choose totalTest, 
please refer to the [post](https://stat.ethz.ch/pipermail/bioconductor/2010-November/036540.html) 
.
In the new version of ChIPpeakAnno, we implement a `permTest` function, in which the number of totalTest is not required. 


```{r makeVennDiagram10,fig.cap="Venn diagram to depict the overlaps between two peak lists",fig.width=6,fig.height=6}
makeVennDiagram(list(peaks1, peaks2), NameOfPeaks=c("TF1", "TF2"), 
                maxgap=0, minoverlap =1, totalTest=100)
```


```{r makeVennDiagram11,fig.cap="venn diagram of overlaps for three input peaklists directly",fig.width=6,fig.height=6}
makeVennDiagram(list(peaks1, peaks2, peaks3), 
                NameOfPeaks=c("TF1", "TF2", "TF3"),
                maxgap=0, minoverlap =1, totalTest=100)
```

For more details about `permTest`, go to section **4.10**.

## Generate annotation data
One main function of ChIPpeakAnno package is to annotate the positional 
relationship between the peaks and the known features, such as TSS, 5UTR, 3UTR etc. 
Constructing and choosing the appropriate annotation data is crucial for this 
process. 

To simplify this process, We precompiled the annotation data for the 
transcriptional starting sites (TSS) of the other species (with 
different genome assembly versions). Those TSS annotations include 
TSS.human.NCBI36, TSS.human.GRCh37, TSS.human.GRCh38, TSS.mouse.NCBIM37, 
TSS.mouse.GRCm38, TSS.rat.RGSC3.4, TSS.rat.Rnor\_5.0, TSS.zebrafish.Zv8, and 
TSS.zebrafish.Zv9. You can access those annotations by R data() function.

To annotate the peaks with other genomic feature, we provided the function
`getAnnotation` with the argument featureType, e.g., "Exon" to obtain 
 the nearest exon, and "miRNA" for finding the nearest miRNA, "5utr" or
 "3utr" to locate the overlapping "5UTR" or "3UTR". You need pass it to the
function `getAnnotation` the appropriate biomaRt dataset for example, 
drerio\_gene\_ensembl for zebrafish genome, mmusculus\_gene\_ensembl for mouse 
genome and rnorvegicus\_gene\_ensembl for rat genome. For a list of available 
biomart and dataset, please refer to the **biomaRt** package documentation
(Durinck S. et al., 2005).  For the detailed usage of `getAnnotation`, you can
type ?`getAnnotation` in R.

You can also pass your own annotation data into the function 
`annotatePeakInBatch`. For example, if you have a list of 
transcription factor biding sites from literatures and are interested in 
obtaining the nearest binding site of the transcription factor and distance to 
it for the list of peaks.

In the newer version of the ChIPpeakAnno (3.3.5), we also implement an 
`annoGR` class,  which is an extension of GRanges class, to represent 
the annotation data. An annoGR object can be created by calling the 
`annoGR`() 
function. The AnnoGR can be constructed from EnsDb, TxDb, or the user defined 
GRanges object. It saves the annotation info in GRanges and it also has
metadata to save the information related to the annotation such as create date, 
source and so on.The advatange of this class is that it contains the meta data 
such as the source and the timestampe (date) of the data souce. Use ?annoGR for 
more information. 

You can also determine to use the biological appropriate database that is 
related with your biological questions. For example, if you only want to 
annotate only the known genes, not other transcipt 
products, such as pseudo genes, you can use the Transcript Db
TxDb.Hsapiens.UCSC.hg19.knownGene. A sample code to build your annotation data 
is: 
```{r annoGRgene}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
annoData <- annoGR(TxDb.Hsapiens.UCSC.hg19.knownGene, feature="gene")
info(annoData)
annoData
```

## Find the nearest feature such as gene and the distance to the feature such as the transcription start site (TSS) of the nearest gene

With the annotation data, we can annotate the peaks identified from 
ChIP-seq or ChIP-chip experiments to retrieve the nearest gene and distance to 
the corresponding gene transcription start site. As discussed in the last 
section,  all the genomic locations of the human genes has been precomplied as 
TSS.human.NCBI36 dataset using function `getAnnotation`. We can pass it
to the argument annotaionData of the `annotatePeakInBatch` function.


```{r annotatePeakInBatch1}
library(ChIPpeakAnno)
data(myPeakList)
data(TSS.human.NCBI36)
annotatedPeak <- annotatePeakInBatch(myPeakList[1:6,], 
                 AnnotationData=TSS.human.NCBI36)
annotatedPeak
```

We can also pass the user defined features as annotationData. A pie chart can be plotted to show the peak distributions among the
features after annotation.


```{r annotatePeakInBatch2}
myPeak1 <- GRanges(seqnames=c("1", "2", "3", "4", "5", "6", 
                              "2", "6", "6", "6", "6", "5"),
                   ranges=IRanges(start=c(967654, 2010897, 2496704, 3075869, 
                                          3123260, 3857501, 201089, 1543200, 
                                          1557200, 1563000, 1569800, 167889600),
                                  end= c(967754, 2010997, 2496804, 3075969, 
                                         3123360, 3857601, 201089, 1555199,
                                         1560599, 1565199, 1573799, 167893599),
                                  names=paste("Site", 1:12, sep="")))

TFbindingSites <- GRanges(seqnames=c("1", "2", "3", "4", "5", "6", "1", "2", 
                                     "3", "4", "5", "6", "6", "6", "6", "6",
                                     "5"),
                          ranges=IRanges(start=c(967659, 2010898, 2496700, 
                                                 3075866, 3123260, 3857500, 
                                                 96765, 201089, 249670, 307586, 
                                                 312326, 385750, 1549800, 
                                                 1554400, 1565000, 1569400,
                                                 167888600), 
                                         end=c(967869, 2011108, 2496920, 
                                               3076166,3123470, 3857780, 
                                               96985, 201299, 249890, 307796, 
                                               312586, 385960, 1550599, 1560799,
                                               1565399, 1571199, 167888999), 
                                         names=paste("t", 1:17, sep="")),
                          strand=c("+", "+", "+", "+", "+", "+", "-", "-", "-", 
                                   "-", "-", "-", "+", "+", "+", "+", "+"))

annotatedPeak2 <- annotatePeakInBatch(myPeak1, AnnotationData=TFbindingSites)
annotatedPeak2
```
```{r pie1,fig.cap="Pie chart of peak distribution among features",fig.width=5,fig.height=5}
pie1(table(as.data.frame(annotatedPeak2)$insideFeature))
```

In the function `annotatyePeakInBatch`, various parameters can be adjusted to 
specify the way to calculate the distance and how the features are selected. For
example, PeakLocForDistance is to specify the location of the peak for calculating 
the distance: "middle" (recommended) means using the middle of the peak, and 
"start" (default, for backward compatibility) means using the start of the peak 
to calculate the distance to features. Similarly, FeatureLocForDistance is to 
specify the location of feature for distance caculation: "middle" means using 
the middle of the feature, "start" means using start of the feature to calculate
the distance from the peak to the feature;  "TSS" (default) means using the 
start of the feature when the feature is on plus strand and using the end of 
feature when the feature is on minus strand; "geneEnd" means using end of the 
feature when feature is on plus strand and using start of feature when feature 
is on minus strand. 

The argument "output" specifies the characteristics of the output of the 
annotated features. The default is "nearestLocation", which means to output the 
nearest features calculated as PeakLocForDistance-FeatureLocForDistance; 
"overlapping" will output overlapping features with maximum gap specified as 
maxgap between peak range and feature range; "shortestDistance" will output the 
nearest features; "both" will output all the nearest features, in addition, will
output any features that overlap the peak that is not the nearest features. 
"upstream\&inside" will output all upstream and overlapping features with maximum
gap. "inside\&downstream" will output all downstream and overlapping features 
within the maximum gap; "upstream" will output all upstream features with 
maximum gap; "downstream" will output all downstream features with maximum gap; 
"upstreamORdownstream" will output all upstream features with maximum gap or 
downstream with maximum gap.

## Add other feature IDs to the annotated peaks

Additional annotations such as entrez ID, gene symbol and gene name can be added
using function addGeneIDs. The annotated peaks can be saved as an Excel file 
or plotted for visualizing the peak distribution relative to the genomic 
features of interest. Here is an example to add gene symbol to the annotated peaks.
Use ?addGeneIDs for more information.


```{r addGeneIDs18}
data(annotatedPeak)
library(org.Hs.eg.db)
addGeneIDs(annotatedPeak[1:6,], orgAnn="org.Hs.eg.db", IDs2Add=c("symbol"))
addGeneIDs(annotatedPeak$feature[1:6], orgAnn="org.Hs.eg.db", 
           IDs2Add=c("symbol"))
```



## Obtain sequences surrounding the peaks

Here is an example to get sequences surrounding the peak intervals 
including 20 bp upstream and downstream sequences for PCR validation or motif 
discovery.


```{r getAllPeakSequence12}
peaks <- GRanges(seqnames=c("NC_008253", "NC_010468"),
                 ranges=IRanges(start=c(100, 500), 
                                end=c(300, 600), 
                                names=c("peak1", "peak2")))
library(BSgenome.Ecoli.NCBI.20080805)
peaksWithSequences <- getAllPeakSequence(peaks, upstream=20, 
                                         downstream=20, genome=Ecoli)
```


The obtained sequences can be converted to fasta format for motif 
discovery by calling the function `write2FASTA`.


```{r write2FASTA13}
write2FASTA(peaksWithSequences,"test.fa")
``` 


## Heatmap for given peak ranges

You can easily observe the signals of multiple Chip-Seq peak files by 
`featureAlignedHeatmap` and
`featureAlignedDistribution`.


```{r heatmap,fig.cap="Heatmap of aligned features",fig.width=4,fig.height=6}
path <- system.file("extdata", package="ChIPpeakAnno")
files <- dir(path, "broadPeak")
data <- sapply(file.path(path, files), toGRanges, format="broadPeak")
names(data) <- gsub(".broadPeak", "", files)
ol <- findOverlapsOfPeaks(data)
#makeVennDiagram(ol)
features <- ol$peaklist[[length(ol$peaklist)]]
wid <- width(features)
feature.recentered <- feature.center <- features
start(feature.center) <- start(features) + floor(wid/2)
width(feature.center) <- 1
start(feature.recentered) <- start(feature.center) - 2000
end(feature.recentered) <- end(feature.center) + 2000
## here we also suggest importData function in trackViewer package 
## to import the coverage.
## compare rtracklayer, it will save you time when handle huge dataset.
library(rtracklayer)
files <- dir(path, "bigWig")
cvglists <- sapply(file.path(path, files), import, 
                       format="BigWig", 
                       which=feature.recentered, 
                       as="RleList")
names(cvglists) <- gsub(".bigWig", "", files)
sig <- featureAlignedSignal(cvglists, feature.center, 
                            upstream=2000, downstream=2000) 
heatmap <- featureAlignedHeatmap(sig, feature.center, 
                                 upstream=2000, downstream=2000,
                                 upper.extreme=c(3,.5,4))
```


```{r distribution,fig.cap="Distribution of aligned features",fig.width=6,fig.height=6}
featureAlignedDistribution(sig, feature.center, 
                           upstream=2000, downstream=2000,
                           type="l")
```


## Output a summary of motif occurrence in the peaks.

Here is an example to search the peaks for the motifs in examplepattern.fa file.


```{r summarizePatternInPeaks17}
peaks <- GRanges(seqnames=c("NC_008253", "NC_010468"),
                 ranges=IRanges(start=c(100, 500), 
                                end=c(300, 600), 
                                names=c("peak1", "peak2")))
filepath <- system.file("extdata", "examplePattern.fa", package="ChIPpeakAnno")
library(BSgenome.Ecoli.NCBI.20080805)
summarizePatternInPeaks(patternFilePath=filepath, format="fasta", skip=0L, 
                        BSgenomeName=Ecoli, peaks=peaks)
```



## Obtain enriched gene ontology (GO) terms or Reactomes terms near the peaks

With the annotated peak data, you can also the function `getEnrichedGO` to obtain a list of 
enriched gene ontology (GO) terms via **GOstats**. The ontology could 
also be set as KEGG or reactome. 

<pre class="r">
<code class="r">
library(org.Hs.eg.db)
enrichedGO = getEnrichedGO(
                     annotatedPeak, 
                     orgAnn="org.Hs.eg.db", 
                     maxP=0.01, 
                     multiAdj=TRUE,  
                     minGOterm=10, 
                     multiAdjMethod="BH")
</code>
</pre>

```{r getEnriched14}
library(org.Hs.eg.db)
over <- getEnrichedGO(annotatedPeak[1:500], orgAnn="org.Hs.eg.db", 
                    maxP=0.01, multiAdj=FALSE, minGOterm=10, 
                    multiAdjMethod="", condense=FALSE)
head(over[["bp"]][, -3])
head(over[["cc"]][, -3])
head(over[["mf"]][, -3])
``` 

Please note that org.Hs.eg.db is the GO gene mapping for Human, for other 
organisms, please refer to 
http://www.bioconductor.org/packages/release/data/annotation/ 
for additional org.xx.eg.db packages.
Or you can try `egOrgMap` to get the annotation database.


```{r egOrgMap15}
egOrgMap("Mus musculus")
egOrgMap("Homo sapiens")
```


## Find peaks with bi-directional promoters

The definition from Wikepedia: Bidirectional promoters are short (&lt;1 kbp), 
intergenic regions of DNA between the 5' ends of the genes in a bidirectional 
gene pair.A "bidirectional gene pair" refers to two adjacent genes coded on 
opposite strands, with their 5' ends oriented toward one another. The two genes 
are often functionally related, and modification of their shared promoter region
allows them to be co-regulated and thus co-expressed. Here is an example to find
peaks with bi-directional promoters and output percent of peaks near 
bi-directional promoters.


```{r peaksNearBDP16}
data(myPeakList)
data(TSS.human.NCBI36)
annotatedBDP <- peaksNearBDP(myPeakList[1:10,], 
                             AnnotationData=TSS.human.NCBI36, 
                             MaxDistance=5000,
                             PeakLocForDistance="middle", 
                             FeatureLocForDistance="TSS")
annotatedBDP$peaksWithBDP
c(annotatedBDP$percentPeaksWithBDP, 
  annotatedBDP$n.peaks, 
  annotatedBDP$n.peaksWithBDP)
```


## Perform permutation test to determine if there is an association between two set of peaks

If there are two peak lists from two transcript factors (TFs), one can ask 
whether they are related TFs. Previously, most of the tests are based on 
hyper-geometric distribution. However, to estimate the total potential binding 
positions for a given TF is not an easy task. With the new `peakPermTest` function 
and the right biological data, we can answer this question properly. 
The random peaks in the permutation test are generated by a special strategy. 
First the input peaks1 is annotated into a given genome to discover its 
distribution from a given feature type (transcripts or exons), then the 
random peaks is generated based on this distribution. The width of the 
peaks also follow the distribution of the inputs.

Following are the sample codes to do the permTest:


```{r peakPermTest}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
cds <- unique(unlist(cdsBy(txdb)))
utr5 <- unique(unlist(fiveUTRsByTranscript(txdb)))
utr3 <- unique(unlist(threeUTRsByTranscript(txdb)))
set.seed(123)
utr3 <- utr3[sample.int(length(utr3), 1000)]
pt <- peakPermTest(utr3, 
             utr5[sample.int(length(utr5), 1000)], 
             maxgap=500,
             TxDb=txdb, seed=1,
             force.parallel=FALSE)
plot(pt)
## highly relevant peaks
ol <- findOverlaps(cds, utr3, maxgap=1)
pt1 <- peakPermTest(utr3,
             c(cds[sample.int(length(cds), 500)], 
                cds[queryHits(ol)][sample.int(length(ol), 500)]), 
             maxgap=500, 
             TxDb=txdb, seed=1,
             force.parallel=FALSE)
plot(pt1)
```


For permutation test, the selection of permutation pool is crucial. If you do not 
set the pool, `peakPermTest` will generate the pool based on the input peaks1, TxDb, 
bindingType and featureType. For ChIP-seq experiments, the pool usually is bigger
than the reality. Accordingly, we pre-built a possible binding pool for human 
(Try ?`wgEncodeTfbsV3` for more information) based on the transcription factor 
binding site clusters (V3) from ENCODE data with the HOT spots removed. 
The HOT spots files are provided in ChIPpeakAnno (Try ?`HOT.spots` to see 
more details). The following code is the sample code to run the permutation 
test.


```{r peakPermTest1}
if(interactive()){
    data(HOT.spots)
    data(wgEncodeTfbsV3)
    hotGR <- reduce(unlist(HOT.spots))
    removeOl <- function(.ele){
        ol <- findOverlaps(.ele, hotGR)
        if(length(ol)>0) .ele <- .ele[-unique(queryHits(ol))]
        .ele
    }
    TAF <- removeOl(data[["TAF"]])
    Tead4 <- removeOl(data[["Tead4"]])
    pool <- new("permPool", grs=GRangesList(wgEncodeTfbsV3), N=length(TAF))
    pt <- peakPermTest(TAF, Tead4, pool=pool, ntimes=1000)
    plot(pt)
}
```
# References
1. Y. Benjamini and Y. Hochberg (1995). Controlling the false discovery rate: a 
practical and powerful approach to multiple testing. J. R. Statist. Soc. B. Vol.
57: 289-300. 

2. Y. Benjamini and D. Yekutieli (2001). The control of the false discovery 
rate in multiple hypothesis testing under dependency. Annals of Statistics. 

3. S. Durinck et al. (2005) BioMart and Bioconductor: a powerful link between 
biological biomarts and microarray data analysis. Bioinformatics, 21, 3439-3440. 

4. S. Dudoit, J. P. Shaffer, and J. C. Boldrick (Submitted). Multiple 
hypothesis testing in microarray experiments. 

5. Y. Ge, S. Dudoit, and T. P. Speed. Resampling-based multiple testing for 
microarray data hypothesis, Technical Report \#633 of UCB Stat. 
http://www.stat.berkeley.edu/~gyc 

6. R. Gentleman et al. (2004) Bioconductor: open software development for 
computational biology and bioinformatics. Genome Biol., 5:R80

7. Y. Hochberg (1988). A sharper Bonferroni procedure for multiple tests of 
significance, Biometrika. Vol. 75: 800-802. 

8. S. Holm (1979). A simple sequentially rejective multiple test procedure. 
Scand. J. Statist.. Vol. 6: 65-70. 

9. N. L. Johnson,S. Kotz and A. W. Kemp (1992) Univariate Discrete 
Distributions, Second Edition. New York: Wiley

10. G. Robertson et al. (2007) Genome-wide profiles of STAT1 DNA association 
using chromatin immunoprecipitation and massively parallel sequencing. Nat 
Methods, 4:651-7.

11. Zhu L.J. et al. (2010) ChIPpeakAnno: a Bioconductor package to annotate 
ChIP-seq and ChIP-chip data. BMC Bioinformatics 2010, 
11:237doi:10.1186/1471-2105-11-237.

12. Zhu L.J. (2013) Integrative analysis of ChIP-chip and ChIP-seq dataset. 
Methods Mol Biol. 2013;1067:105-24. doi: 10.1007/978-1-62703-607-8\_8.

# Session Info
```{r sessionInfo, results='asis'}
sessionInfo()
```